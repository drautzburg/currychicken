\documentclass{article}
%include lhs2TeX.fmt
%include lhs2TeX.sty
%format <-- = "\boldmath{${\leftarrow}$}"
%format <- = "\char''30"
%options ghci
\usepackage{fancyhdr}
\pagestyle{fancy}
\usepackage{ragged2e}
\usepackage[parfill]{parskip}
\usepackage{pgf}
\usepackage{needspace}
\usepackage[framemethod=tikz]{mdframed}
\newmdenv[frametitle=Example,backgroundcolor=blue!05,roundcorner=2pt]{example}
\newmdenv[frametitle=Running it,backgroundcolor=gray!05,roundcorner=2pt]{run}
\usepackage[utf8]{inputenc}
\newlength{\currentparskip}

\author{Martin Drautzburg}

\title{Temporal Data}

\begin{document} \maketitle \tableofcontents 


\section{Behavior}

\begin{code}
import Data.List
import Data.List.Ordered
import Debug.Trace
import Text.Printf
import Text.Show.Pretty as Pr

type Day = Int
\end{code}


A |Behavior| is a value which can change from day to day. When the day
is known, we can ask for the value which is valid on that day. So a
|Behavior| is a function from |Day| to something.

\begin{code}
class Behavior b where
        at :: (Eq a) => b a -> Day -> a

\end{code}

We can also scan a number of days, and we expect a list of days, each
one associcated with a value.

\begin{code}
between :: (Eq v, Behavior b) => Day -> Day -> b v -> [(Day, v)]
between d1 d2 bhvr = zip [d1..d2] (map (at bhvr) [d1 .. d2])
\end{code}

Or we can ask for seven days in a row. While this is a full week, it
does not have to start on a Monday or any other specific weekday.

\begin{code}
weekFollowing :: (Eq v, Behavior b) => Day -> b v ->  [(Day, v)]
weekFollowing day bhvr = between day (day+6) bhvr
\end{code}

\subsection{Change}

A |Change| is one implementation of a |Behavior| and is described as a
default value plus a number of changes. Each change is described by a
|Day| and the value which shall be valid from then on.

\begin{code}
data Change v = Change v [(Day,v)] 
                deriving(Eq, Show)

\end{code}

The list of changes must be kept ordered by day. When we insert a new
change, we better make sure this ordering is preserved. Also, if we
insert a change, where there was already a change, the original change
must be replaced.

\begin{code}
insertChange :: Day -> v -> (Change v) -> (Change v)
insertChange  d x (Change def chgs) = (Change def chgs')
        where
            clean = filter (\(dx,_) -> dx /= d) chgs 
            chgs' = insertBagBy dayOrder (d,x) clean
            dayOrder (d1,_) (d2,_) = compare d1 d2
\end{code}

If there are no changes, we will always get the default value. A
complex |Change| is typically constructed by a number of
|insertChange| calls and the initial |Change| is just the default
value. To make that look prettier, we define this function:

\begin{code}
normally a = (Change a []) 
\end{code}

To make |Change| and instance of |Behavior| we must implement the |at|
function. Since we know, that the list of changes is ordered, we need
to take the default if the first day in the list is already later that
the day we're asking for. Otherwise, we make the value of the first
day the default and continue with the rest of the list.

\begin{code}
instance Behavior Change where
        at (Change def []) _ = def
        at (Change def ((d,v):cs)) day 
           | d > day   = def
           | otherwise = at (Change v cs) day

\end{code}

We will use |String|s as values for demonstration purposes. In reality
values can have any type.

\needspace{20\baselineskip}
\begin{example}
\begin{code}
exampleChange = 
    (insertChange 2 "two")   $
    (insertChange 8 "eight") $ 
    (insertChange 4 "four")  $
    (insertChange 10 "ten") (normally "")               
\end{code}
\end{example}

\needspace{20\baselineskip}
\begin{run}
|*Main> exampleChange|\\
  \eval{exampleChange}


|*Main> between 1 5 exampleChange |\\
  \eval{between 1 5 exampleChange}

|*Main> at exampleChange 3|\\
  \eval{at exampleChange 3}

\end{run}

\subsection{Repeat}

|Repeat| is an alternative way of specifying a |Behavior|. While
|Change| expresses things which change at a certain day, |Repeat|
expresses a |Behavior|, which changes depending on the weekday and
which repeats every week.

To preserve the semantics of |Behavior| we must be able to specify a
value for every day of the week.

Using pattens like |MTW----| is attractive, because we can cover three
(or more) days in a concice way. However it bares the risk of
overlapping patterns. If |M-W-F-S| is associated with one value and
|MT-T-S-| with another, what value do we expect on Monday?

|Change| does not suffer from this problem. In fact there is not much
difference between |Change| and |Repeat|. The only difference is
that we must take the day-of-the-week instead of the day itself, when
we ask for a value using |at|. And of course there is no point in
specifying days larger than 6 in the list of changes -- they would
have no effect.

\begin{code}

data Repeat v = Repeat (Change v)
                        deriving (Eq)

instance Behavior Repeat where
        at (Repeat change) day = at change (day `mod` 7)
\end{code}

We may however, wish to present |Repeats| as a list of
|(Value,Pattern)|. This apparently simple transformation requires a
lot of code (by Haskell standards). This may indicate, that this kind
of representation bares some hidden complexity.

\begin{code}
asPatterns :: (Ord v, Show v) => [(Day, v)] -> [(v, String)]
asPatterns betweens = map combine $ group $ betweens
        where
            group xs  = let val cmp l1 l2 = cmp (snd l1) (snd l2)
                        in groupBy (val (==)) $ 
                           sortBy (val compare) xs
            combine xs = let value = snd $ head xs
                             pattern = foldr f "-------" xs
                             f (d,v) pat 
                                     = let d' = d `mod` 7
                                       in
                                           (take d' pat) 
                                           ++ ["MTWTFSS" !! d' ] 
                                           ++ (drop (d'+1) pat)
                         in (value, pattern)

-- use |asPattern| when printing |Repeat|
instance (Ord v, Show v) => Show (Repeat v) where
       show x = "Repeat " ++ (show $ asPatterns $ between 0 6 x)

\end{code}

\needspace{20\baselineskip}
\begin{example}
\begin{code}
exampleRepeat = Repeat $
                        (insertChange 0 "Even")  $
                        (insertChange 5 "End") $ 
                        (insertChange 2 "Even")  $ 
                        (insertChange 1 "Odd")  (normally "") 
                                  

\end{code}
\end{example}


\begin{run}
|*Main> exampleRepeat|\\
  \eval{exampleRepeat}


|*Main> at exampleRepeat 0|\\
  \eval{at exampleRepeat 0}

|*Main> at exampleRepeat 1|\\
  \eval{at exampleRepeat 1}

|*Main> at exampleRepeat 2|\\
  \eval{at exampleRepeat 2}

|*Main> at exampleRepeat (2+7)|\\
  \eval{at exampleRepeat (2+7)}

\end{run}



\subsection{Evolution}

We chose the term |Evolution| to describe a |Behavior| which changes
depending on the day-of-the-week and additionally on certan days. This
is a typical thing in planning scenarios.

Conceptually this is a |Behavior| of a |Behavior|. The second (inner)
|Behavior| is a |Repeat| and gives us a value for every
day-of-the-week. The outer |Behavior| describes how the inner
|Behavior| changes over time.

\begin{code}
data Evolution a = Evolution (Change (Repeat a))
                 deriving (Eq,Show)

instance Behavior Evolution where
        at (Evolution chg) day = at repeating day
                where
                    repeating = at chg day


\end{code}

\needspace{20\baselineskip}
\begin{example}
\begin{code}
exampleEvolution = 
        let defaultWeek = 
                    Repeat $
                          (insertChange 0 "DefaultWkday")$
                          (insertChange 5 "DefaultWkend")  
                          (normally "") 
            winterWeek =
                    Repeat $
                          (insertChange 0 "WinterEven")  $
                          (insertChange 5 "WinterWkend") $ 
                          (insertChange 2 "WinterEven")  $ 
                          (insertChange 1 "WinterOdd")  
                          (normally "") 
            summerWeek =
                    Repeat $
                          (insertChange 0 "SummerEven")  $
                          (insertChange 5 "DefaultWkend")$ 
                          (insertChange 2 "SummerEven")  
                          (normally "") 
        in Evolution $
                   (insertChange 40 winterWeek) $
                   (insertChange 80 summerWeek) 
                   (normally defaultWeek)
          

\end{code}
\end{example}

\begin{run}
|*Main> between 39 40 exampleEvolution|\\
  \eval{between 39 49 exampleEvolution}

|*Main> asPatterns $ weekFollowing 35 exampleEvolution|\\
  \eval{asPatterns $ weekFollowing 35 exampleEvolution}
\end{run}

\subsection{Exception Days}

If we want to create an exception day, i.e. a day where something
happens out of the ordinary, we must replace the |Repeat| which is
valid at that day by another |Repeat|. Since we only want to change a
single day, there is no point in replacing it by a full-fleged
repeat. We do not need to know what happens on every day-of-the-week.

So, the |Repeat| which holds the exceptional value only needs a
default value. We cannot elegantly specify an exceptional
\emph{weekend} this way, but we are only providing a convenience
operation here. If more than one day changes, it is better to use the
standard functionality and specify a full alternative week.

The day after the exception day, we must restore whatever |Repeat|
used to be valid then.  

\begin{code}

exceptionDay :: Eq v => Day -> v -> Evolution v -> Evolution v
exceptionDay  day val (Evolution chg) = 
        let 
            nextRep = at chg (day+1)
            xcptRep = (Repeat (normally val))
        in 
            Evolution $ 
              (insertChange day (xcptRep))  $
              (insertChange (day+1) nextRep) 
              chg

\end{code}

\begin{run}

--- Look at the unchanged example: ---

|*Main> between 39 41 exampleEvolution|\\
  \eval{between 39 41 exampleEvolution }

--- Define two shortcuts to insert exception days ---

|*Main> let exc1 = exceptionDay 39 "Ex39"|\\
  \eval{let exc1 = exceptionDay 39 "Ex39"}
  \eval{:t exc1}

|*Main> let exc2 = exceptionDay 40 "Ex40"|\\
  \eval{let exc2 = exceptionDay 40 "Ex40"}
  \eval{:t exc2}

--- Apply the first one ---

|*Main> between 39 41 (exc1 exampleEvolution)|\\
  \eval{between 39 41 (exc1 exampleEvolution) }

--- Apply both ---

|*Main> between 39 41 (exc2 $ exc1 exampleEvolution) |\\
  \eval{between 39 41 (exc2 $ exc1 exampleEvolution) }





\end{run}
\end{document}